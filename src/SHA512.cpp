// SHA512.cpp

#include "SHA512.h"
#include "SHAUtils.h"
#include <bitset>
#include <sstream>
#include <iomanip>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <vector>
#include <string>
#include <cstdlib>

using sha_utils::toBinary, sha_utils::toULL, sha_utils::rotateLeft;
using std::string, std::stringstream, std::rotate;
using std::pow;
using std::vector, std::bitset;
using std::cerr, std::cout;
using std::exit;
using std::setw, std::setfill, std::hex;

SHA512::SHA512() {
    H = {
        "0110101000001001111001100110011111110011101111001100100100001000",
        "1011101101100111101011101000010110000100110010101010011100111011",
        "0011110001101110111100110111001011111110100101001111100000101011",
        "1010010101001111111101010011101001011111000111010011011011110001",
        "0101000100001110010100100111111110101101111001101000001011010001",
        "1001101100000101011010001000110000101011001111100110110000011111",
        "0001111110000011110110011010101111111011010000011011110101101011",
        "0101101111100000110011010001100100010011011111100010000101111001"
    };

    K = {
        "0100001010001010001011111001100011010111001010001010111000100010", "0111000100110111010001001001000100100011111011110110010111001101",
        "1011010111000000111110111100111111101100010011010011101100101111", "1110100110110101110110111010010110000001100010011101101110111100",
        "0011100101010110110000100101101111110011010010001011010100111000", "0101100111110001000100011111000110110110000001011101000000011001",
        "1001001000111111100000101010010010101111000110010100111110011011", "1010101100011100010111101101010111011010011011011000000100011000",
        "1101100000000111101010101001100010100011000000110000001001000010", "0001001010000011010110110000000101000101011100000110111110111110",
        "0010010000110001100001011011111001001110111001100110011000010101", "0101010100001100011111011100001111010010001000011100010011101110",
        "0111001010111110010111010111010011110010011110111000100101101111", "1000000011011110101100011111111000111011101111000001010110100011",
        "1001101111011100000001101010011100100101110001110001001000110101", "1100000110011011111100010111010011001111011010010010011010010100",
        "1110010010011011011010011100000110011101100010100010111010000011", "1110111110111110010001111000011000111000010011110010000000100001",
        "0000111111000001100111011100011000001011010000011001010100110101", "0010010000001100101000011100110001110111101011000111111011101100",
        "0010110111101001001011000110111101011001001010110000001001110101", "0100101001110100100001001010101001101110101001100011011101101100",
        "0101110010110000101010011101110010111101010000011111011001011000", "0111011011111001100010001101101010000011000100010101001110110101",
        "1001100000111110010100010101001011101110011001101101111110101011", "1010100000110001110001100110110100101101101101001000011011010010",
        "1011000000000011001001111100100010011000110010000101100100001001", "1011111101011001011111111100011110111110111000000000011011001111",
        "1100011011100000000010111111001100111101100010000111110101100100", "1101010110100111100100010100011110010011000010101010011100100101",
        "0000011011001010011000110101000100010011010010010110110010011110", "0001010000101001001010010110011100001010000011101010000111101000",
        "0010011110110111000010101000010101000110110100100010111111111001", "0010111000011011001000010011100001011100001001101101100100101110",
        "0100110100101100011011011111110001011010110000001111000100110101", "0101001100111000000011010001001101100101110110111010101011101001",
        "0110010100001010011100110101010010001011101011110100001100110100", "0111011001101010000010101011101100111111101100110000101111110111",
        "1000000111000010110010010010111001000111011001100010101100111100", "1001001001110010001011001000010100010100100000100011010100111011",
        "1010001010111111111010001010000101001100111110001111110000101010", "1010100000011010011001100100101110111100010000100011000000000001",
        "1100001001001011100010110111000011010000111110001001011110010001", "1100011101101100010100011010001100000110010101001011111000110000",
        "1101000110010010111010000001100111010110111011110101001000011000", "1101011010011001000001100010010011010000001100111010010001000101",
        "1111010000001110001101011000010101010100000000000000101111011011", "0001000001101010101000000111000000110010101110111101000110111000",
        "0001100110100100110000010001011000011110001101110110110001011110", "0001111000110111011011000000100010000100010110100001001101110111",
        "0010011101001000011101110100110001010101010100111011101110100011", "0011010010110000101111001011010111000001111100110101100010000110",
        "0011100100011100000011001011001111000101110010010101000101100011", "0100111011011000101010100100101001111100010011010101010100100010",
        "0101101110011100110010100100111101111010100010010011001000001011", "0110100000101110011011111111001111010110100011110010100000111110",
        "0111010010001111100000101110111001011110111000001000111101100001", "0111100010100101011000110110111101000011000101111001100011001010",
        "1000010011001000011110000001010001001011000001110110010010001101", "1000110011000111000000100000100001010000011011010001111000000101",
        "1001000010111110111111111111101001001100011010001000110010100011", "1010010001010000011011001110101111011110000111111011010111000100",
        "1011111011111001101000111111011110110000010010000001000111001001", "1100011001110001011110001111001011100011011101010110010111011001",
        "1100101101110111101001001100000001000111010010101110110000100110", "1101000000101000110101001000100001101000001100111101110010110100",
        "1101100111010100110100000011100111100110110010010000111110000100", "1110010100000101101001100010010001011000000111000001001110110101",
        "1110110101011010010000110110000001001100001101000111100100010000", "1111010011011000111111011000011110010001111111110100000010010000",
        "1111100111011110011011010111100110000101010010001111010110111100", "1111110110001000011111011000010110111111111000000000100101110110",
        "1111111110011110101000010010011111011001010001011000010011000101", "0000010101010101011000001011110110100001001001101101000111000111",
        "0000101110001011100010110000000001001110010010001000000000101100", "0001100100010111110011011101101011011101101001000111111100110110",
        "0010010100001100100100110111101010000100110010001011000001011111", "0010110010010010011111000010101010010010110100001100000010010011",
        "0011100110011001100001011100101000001011101101100101011001110101", "0100100001011010111101100011110111001011101111110001010001011011",
        "0101110010010110010100110001010111101000011010000101001110000011", "0110001111001010011110110110011100100110010000111111010001001100",
        "0110100000101110011011111111001111010110100011110010100000111110", "0111100010100101011000110110111101000011000101111001100011001010",
        "1000000011110011001001101011111101110100010100111110001101001110", "1000101111101011001011110111000000010100001000011110101111000101",
        "1001010110111001011110100000001001100101110001010011111010010001", "1001111110101111110000001011111100001001110101001100001111010010",
        "1011111001110111111011101110011010110010111000011000101110001101", "1100101110000010000001010001100011110011110100101100110101011001"
    };
}

void SHA512::hashString(const string& st) {
    int size = st.size();
    if (size * 8 > (pow(2, 128) - 128)) { // Technically SHA-512 limit is 2^128 bits, but pow(2,128) overflows double.
        // For this implementation, we are limited by string size anyway.
        // Let's just assume it fits for now or use a simpler check if needed.
    }
    int bits = calcBits(size);
    string binStr = toBinary(st, bits);
    int N = bits / 1024;
    vector<string> M;
    mSplit(M, binStr, N);
    vector<string> W;
    blockComp(N, M, W);
}

void SHA512::display() const {
    cout << "\nHash value: ";
    for (int i = 0; i < 8; i++) {
        bitset<64> bits(H[i]);
        stringstream ss;
        ss << hex << setw(16) << setfill('0') << bits.to_ullong();
        cout << ss.str();
    }
    cout << '\n';
}

int SHA512::calcBits(int size) {
    size = 8 * size;
    int rounded = ((size / 1024) + 1) * 1024;
    if (size >= rounded - 128)
        rounded += 1024;
    return rounded;
}

void SHA512::mSplit(vector<string>& M, const string& binStr, int N) {
    for (int i = 0; i < N * 16; i++) {
        M.push_back(binStr.substr(64 * i, 64));
    }
}

string SHA512::sigma(const string& s, int a1, int a2, int a3) {
    unsigned long long val = toULL(s);
    unsigned long long res = rotateLeft(val, 64 - a1) ^ rotateLeft(val, 64 - a2) ^ (val >> a3);
    return bitset<64>(res).to_string();
}

string SHA512::SIGMA(const string& s, int a1, int a2, int a3) {
    unsigned long long val = toULL(s);
    unsigned long long res = rotateLeft(val, 64 - a1) ^ rotateLeft(val, 64 - a2) ^ rotateLeft(val, 64 - a3);
    return bitset<64>(res).to_string();
}

string SHA512::choose(const string& e, const string& f, const string& g) {
    string st;
    for (int i = 0; i < 64; i++) {
        st.push_back(e[i] == '0' ? g[i] : f[i]);
    }
    return st;
}

string SHA512::maj(const string& a, const string& b, const string& c) {
    string st;
    for (int i = 0; i < 64; i++) {
        st.push_back(a[i] == b[i] ? a[i] : (b[i] == c[i] ? b[i] : c[i]));
    }
    return st;
}

void SHA512::blockComp(int N, const vector<string>& M, vector<string>& W) {
    for (int i = 0; i < N; i++) {
        W.insert(W.end(), M.begin() + 16 * i, M.begin() + 16 * (i + 1));
        for (int t = 16; t < 80; t++) {
            unsigned long long result = toULL(sigma(W[t - 2], 19, 61, 6)) +
                                     toULL(W[t - 7]) +
                                     toULL(sigma(W[t - 15], 1, 8, 7)) +
                                     toULL(W[t - 16]);
            W.push_back(bitset<64>(result).to_string());
        }
        string a = H[0], b = H[1], c = H[2], d = H[3], e = H[4], f = H[5], g = H[6], h = H[7];
        for (int t = 0; t < 80; t++) {
            unsigned long long T1 = toULL(h) + toULL(SIGMA(e, 14, 18, 41)) + toULL(choose(e, f, g)) + toULL(K[t]) + toULL(W[t]);
            unsigned long long T2 = toULL(SIGMA(a, 28, 34, 39)) + toULL(maj(a, b, c));
            
            h = g;
            g = f;
            f = e;
            e = bitset<64>(toULL(d) + T1).to_string();
            d = c;
            c = b;
            b = a;
            a = bitset<64>(T1 + T2).to_string();
        }
        H[0] = (bitset<64>(toULL(a) + toULL(H[0]))).to_string();
        H[1] = (bitset<64>(toULL(b) + toULL(H[1]))).to_string();
        H[2] = (bitset<64>(toULL(c) + toULL(H[2]))).to_string();
        H[3] = (bitset<64>(toULL(d) + toULL(H[3]))).to_string();
        H[4] = (bitset<64>(toULL(e) + toULL(H[4]))).to_string();
        H[5] = (bitset<64>(toULL(f) + toULL(H[5]))).to_string();
        H[6] = (bitset<64>(toULL(g) + toULL(H[6]))).to_string();
        H[7] = (bitset<64>(toULL(h) + toULL(H[7]))).to_string();
        W.clear();
    }
}
